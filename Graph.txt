import java.util.*;


class Graph{



public static void main(String [] args){
int v=8;



int g[][]=new int [v+1][v+1];

ArrayList<ArrayList<Integer>> gL= new ArrayList<>();
for(int i=0; i<=v; i++){
gL.add(new ArrayList<Integer>());}


addEdge(g,1,2);
addEdge(g,1,3);
addEdge(g,4,5);
addEdge(g,1,4);
addEdge(g,4,1);

addEdgeL(gL,1,2);
addEdgeL(gL,1,3);
addEdgeL(gL,4,5);
addEdgeL(gL,1,4);
addEdgeL(gL,4,1);
addEdgeL(gL,6,7);
addEdgeL(gL,7,8);

printGraphL(gL,v);
System.out.println(bfs(gL,5,v));


printGraph(g,v);
System.out.println(componenets(gL,v));


 
}



    

private static void addEdge(int g[][],int Source ,int Dest){

g[Source][Dest]=1;
g[Dest][Source]=1;



}

private static void addEdgeL(ArrayList<ArrayList<Integer>> gL,int Source ,int Dest){

gL.get(Source).add(Dest);
gL.get(Dest).add(Source);


}

public static void printGraph(int g[][],int v){

for(int i=1; i<=v; i++){
for(int j=1; j<=v; j++){
System.out.print(g[i][j] + " ");

}
System.out.println();
}

}

public static void printGraphL(ArrayList<ArrayList<Integer>> gL,int v){

for(int i=0; i<=v; i++){
System.out.print(i +"->");
for(int node:gL.get(i)){
System.out.print(node+ " ");
}
System.out.println();
}}


////////////////////////////////////***************BFS OF Graph*******************///////////////////////////

public static List<Integer> bfs(ArrayList<ArrayList<Integer>> gL,int Source,int v){

List<Integer> bfs=new ArrayList<>();
Queue<Integer> q=new LinkedList<>();

boolean [] visited=new boolean[v+1];

q.add(Source);
visited[Source]=true;

while(!q.isEmpty()){

int node=q.poll();
bfs.add(node);

for(int nbr:gL.get(node)){

if(!visited[nbr]){
visited[nbr]=true;
q.add(nbr);

}}}

return bfs;


}

public static int componenets(ArrayList<ArrayList<Integer>> gL,  int v){
int comp=0;

boolean [] Visited=new boolean [v+1];
Queue<Integer> q=new LinkedList<>();
for(int i=1; i<Visited.length; i++){
 if (!Visited[i]) {
            comp++;
q.add(i);

Visited[i]=true;

while(!q.isEmpty()){
int node=q.poll();

for(int j=0; j<gL.get(node).size(); j++){

int nbr=gL.get(node).get(j);
if(Visited[nbr]!=true){
Visited[nbr]=true;
q.add(nbr);}}}}}



return comp;}
         












public static void dfs(ArrayList<ArrayList<Integer>> gL,int Source, int v){










}

////////////////////////////////////Minimum Spaning Tree Weight////////////////////////////////////////////////


static int spaningTree(int v,ArrayList<ArrayList<ArrayList<Integer>>> gLL){

boolean visited[]=new boolean[v];

PriorityQueue<Pair> q=new PriorityQueue<>();

q.add(new Pair(0,0));

int ans=0;

while(!q.isEmpty()){

Pair cur=q.remove();

int u=cur.v;

if(visited[u]){
continue;}

ans=ans+cur.wt;
visited[u]=true;


ArrayList<ArrayList<Integer>> neighbour=gLL.get(u);

for (ArrayList<Integer> list:neighbour){
int vertex=list.get(0);
int wt=list.get(1);

if(visited[vertex]==false){
q.add(new Pair(vertex,wt));
}
}



}

return ans;}

/////////////////////////////////////////////////////Dijkstra Algorithm///////////////////////////////////////////////////

static int[] dijkstra (ArrayList<ArrayList<ArrayList<integer>>> gLD,int v,int source){

int dist[]=new int [v];
Arrays.fill(dist,Integer.MAX_VALUE);
boolean visited[]=new boolean[v];

PriorityQueue<Pair> q=new PriorityQueue<>();

dist[source]=0;

q.add(new Pair(source,0));

while(!q.isEmpty()){
Pair cur=q.remove();

int u=cur.v;

if(visited[u]) continue;
visited[u]=true;

ArrayList<ArrayList<Integer>> neighbours = gLD.get(u);

for(ArrayList<Integer> list : neighbours)){

int vertex=list.get(0);

int wt=list.get(1);

if(!visited[vertex] && dist[u]+wt<dist[vertex]){
dist[vertex]=dist[u]+wt;
q.add(new Pair(vertex,dist[vertex]));}

}}
return dist;

}










































}


class Pair implements Comparable<Pair>{
int wt;
int v;

Pair(int wt,int v){

this.v=v;
this.wt=wt;}

public int compareTo(Pair that){

return this.wt-that.wt;}}





