
//Tree Data Sructure

import java.util.*;

public class Tree{

static Scanner sc=null;
static Node Prev = null, head = null;



//************************Main Method************************//

public static void main(String[] args){
sc =new Scanner(System.in);

Node root=createTree();
System.out.print("Preorder Traversal");
preOrder(root);
System.out.print("Inorder Traversal");
inOrder(root);
System.out.print("Postorder Traversal");
postOrder(root);

levelOrderTraversal(root);

levelOrder(root);
ArrayList<Integer> ans=topView(root);
System.out.println("Top view of tree" + ans);

ArrayList<Integer> aans=bottomView(root);
System.out.println("Bottom view of tree" +aans);

ArrayList<Integer> vAns=verticalTraversal(root);
System.out.println("Vertical  view of tree" +vAns);

leftView(root);

System.out.println("Give Numbers for to find Lowest Common Ancestor");

int n1=sc.nextInt();
int n2=sc.nextInt();


Node Lca=lca(root,n1,n2);

System.out.println("LCA of" +n1+ " and " + n2 +"is" +Lca.nodeVal); 


System.out.println("Give the node value from which you want to find minimum time to burn the tree");
int target=sc.nextInt();

int burnAns=minTime(root,target);

System.out.println("Minimum time to burn the tree is" +burnAns);


}



//**************************Create A Tree**************//


private static  Node createTree(){

Node root=null;
System.out.println("Enter Node value");
int nodeVal=sc.nextInt();

if(nodeVal==-1) return null;

root=new Node(nodeVal);

System.out.println("Enter Node Value for  Left of " +nodeVal);

root.left=createTree();

System.out.println("Enter Node Value for Right of" +nodeVal);

root.right=createTree();

return root;}



//***************************Inorder Traversal of Binary Tree*******************************////////




public static void inOrder(Node root){

if(root==null) return ;

inOrder(root.left);
System.out.print(root.nodeVal+" ");
inOrder(root.right);
}


//********************************Postorder Traversal of Binary Tree************************///////////////




public static void postOrder(Node root){
if(root==null) return;

postOrder(root.left);
postOrder(root.right);
System.out.print(root.nodeVal+" ");

}



//********************************Preorder Traversal of Binary Tree******************//////////////////////////



private static void preOrder(Node root){
if(root==null) return;

System.out.print(root.nodeVal+" ");
preOrder(root.left);
preOrder(root.right);

}


//****************************Level Order Traversal************************************************///////////////////


public static void levelOrderTraversal(Node root){

Queue<Node> q=new LinkedList<>();

q.add(root);

while(!q.isEmpty()){

Node a=q.poll();

System.out.println(a.nodeVal);

if(a.left!=null){
q.add(a.left);}

if(a.right!=null){
q.add(a.right);}


}}

//Average Of Levels

public static void levelOrder(Node root){



Queue<Node> q=new LinkedList<>();

q.add(root); q.add(null);

System.out.print("Left View: " + root.nodeVal +"| ");
while(!q.isEmpty()){

Node a=q.poll();
if(a==null) {

System.out.println();
if(q.isEmpty()) return;

System.out.print("Left View: " + q.peek().nodeVal +"| ");
q.add(null);

continue;
}
System.out.println(a.nodeVal);

if(a.right!=null){
q.add(a.right);}

if(a.left!=null){
q.add(a.left);}

}}



//*************************************Left View Of a Binary Tree*****************************//////////////////////////////////

  public static void leftView(Node root) {
        List<Node> list = new ArrayList<>();
        leftViewutil(root, list, 0);
        for (Node node : list) {
            System.out.println(node.nodeVal);
        }
    }

    static void leftViewutil(Node root, List<Node> list, int level) {
        if (root == null)
            return;
        if (list.size() == level) {
          
            list.add(root);
        }
        leftViewutil(root.left, list, level + 1);
        leftViewutil(root.right, list, level + 1);
    }



//*************************************Top View Of a Binary Tree*****************************//////////////////////////////////


static ArrayList<Integer> topView (Node root){


Queue<Pair> q=new ArrayDeque<>();
Map<Integer,Integer> mp =new TreeMap<>();

q.add(new Pair(0,root));


while(!q.isEmpty()){

Pair cur=q.poll();

if(!mp.containsKey(cur.d)){
mp.put(cur.d,cur.node.nodeVal);}


if(cur.node.left!=null){

q.add(new Pair(cur.d-1, cur.node.left));}



if(cur.node.right!=null){

q.add(new Pair(cur.d+1,cur.node.right));}



}

ArrayList<Integer> ans=new ArrayList<>();

for(Map.Entry<Integer,Integer> entry: mp.entrySet()){
ans.add(entry.getValue());


}
return ans;}


//*************************************Bottom View Of a Binary Tree*****************************//////////////////////////////////


static ArrayList<Integer> bottomView(Node root){

Queue<Pair> q=new ArrayDeque<>();

Map<Integer,Integer> mp=new TreeMap<>();

q.add( new Pair(0,root));

while(!q.isEmpty()){
Pair cur=q.poll();

mp.put(cur.d, cur.node.nodeVal);

if(cur.node.left!=null){
q.add(new Pair(cur.d-1,cur.node.left));
}

if(cur.node.right!=null){
q.add(new Pair(cur.d+1,cur.node.right));
}

}
ArrayList<Integer> ans=new ArrayList<>();

for(Map.Entry<Integer,Integer> entry:mp.entrySet()){
ans.add(entry.getValue());}

return ans;
}

//*************************************Vertical Order Traversal  Of a Binary Tree*****************************//////////////////////////////////

static ArrayList<Integer> verticalTraversal(Node root){

Queue <Pair> q=new ArrayDeque<>();

Map<Integer, ArrayList<Integer>> mp=new TreeMap<>();

q.add(new Pair(0,root));

while(!q.isEmpty()){
Pair cur=q.poll();
if(mp.containsKey(cur.d)){
mp.get(cur.d).add(cur.node.nodeVal);}

else{
ArrayList <Integer> temp=new ArrayList<>();
temp.add(cur.node.nodeVal);
mp.put(cur.d,temp);
}
if(cur.node.left!=null){
q.add(new Pair(cur.d-1,cur.node.left));}

if(cur.node.right!=null){
q.add(new Pair(cur.d+1,cur.node.right));}

}

ArrayList<Integer> ans= new ArrayList<>();

for(Map.Entry<Integer,ArrayList<Integer>> entry:mp.entrySet()){
ans.addAll(entry.getValue());
}

return ans;


}


//*************************************Lowest Common Ancestor  Of two nodes in a Binary Tree*****************************//////////////////////////////////

static Node lca(Node root,int n1,int n2){

if(root==null) return null;

if(root.nodeVal==n1|| root.nodeVal==n2) return root;

Node leftLCA=lca(root.left,n1,n2);

Node rightLCA=lca(root.right,n1,n2);

if(leftLCA==null) return rightLCA;
if(rightLCA==null) return leftLCA;

return root;



}

//*************************************Mininimun Time to Burn all the Nodes in a Binary Tree starting from a given node*****************************//////////////////////////////////

public static int minTime(Node root, int target){

Depth depth=new Depth(-1);
burn(root, target,depth);
return bAns;
}
static int bAns=-1;

public static int burn(Node root, int target, Depth depth){

if (root==null) return 0;

if (root.nodeVal==target){
depth.d=1;
return 1;}

Depth ld=new Depth(-1);
Depth rd=new Depth(-1);

int lh=burn(root.left,target,ld);
int rh=burn(root.right,target,rd);

if(ld.d!=-1){
bAns=Math.max(bAns,ld.d+1+rh);
depth.d=ld.d+1;
}
else if(rd.d!=-1){
bAns=Math.max(bAns,rd.d+1+lh);
depth.d=rd.d+1;
}

return Math.max(lh,rh)+1;


}


//*************************************Convert a Binary Tree to a Doubly Linked List*****************************//////////////////////////////////


static Node converTODLL(Node root){

 Prev=null;
  head=null;

convertToDLLUtil(root);
return head;

}

private static void convertToDLLUtil(Node root){

if(root==null) return ;

convertToDLLUtil(root.left);
if(Prev==null) head=root;

else{
root.left=Prev;
Prev.right=root;


}

Prev=root;
convertToDLLUtil(root.right);
}

}




class Depth{
int d;
public Depth(int d){
this.d=d;
}}




 class Pair{

int d;
Node node;

public Pair(int d,Node node){

this.node=node;
this.d=d;

}




}

class Node{

Node left,right;

 int nodeVal;

public Node(int nodeVal){
this.nodeVal=nodeVal;
}}










 

































