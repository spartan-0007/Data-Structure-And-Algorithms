import java.util.*;

class Graph{

    int [] rank,parent;
    int n;


    public static void main(String [] args){
        int v=6;

        int g[][]=new int [v+1][v+1];

        ArrayList<ArrayList<Integer>> gL= new ArrayList<>();
        for(int i=0; i<=v; i++){
            gL.add(new ArrayList<Integer>());
        }

        addEdge(g,1,2);
        addEdge(g,1,3);
        addEdge(g,4,5);
        addEdge(g,1,4);
        addEdge(g,4,1);

        addEdgeL(gL,1,2);
        addEdgeL(gL,1,3);
        addEdgeL(gL,4,5);
       // addEdgeL(gL,1,4);
        addEdgeL(gL,4,1);
      //  addEdgeL(gL,6,7);
     //   addEdgeL(gL,7,8);

        printGraphL(gL,v);
        System.out.println(bfs(gL,5,v));

        printGraph(g,v);
        System.out.println(componenets(gL,v));
  System.out.println(topologicalSort(gL,v));


    }


    private static void addEdge(int g[][],int Source ,int Dest){
        g[Source][Dest]=1;
        g[Dest][Source]=1;
    }

    private static void addEdgeL(ArrayList<ArrayList<Integer>> gL,int Source ,int Dest){
        gL.get(Source).add(Dest);
      //  gL.get(Dest).add(Source);
    }

    public static void printGraph(int g[][],int v){
        for(int i=1; i<=v; i++){
            for(int j=1; j<=v; j++){
                System.out.print(g[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static void printGraphL(ArrayList<ArrayList<Integer>> gL,int v){
        for(int i=0; i<=v; i++){
            System.out.print(i +"->");
            for(int node:gL.get(i)){
                System.out.print(node+ " ");
            }
            System.out.println();
        }
    }

    ////////////////// BFS /////////////////////////

    public static List<Integer> bfs(ArrayList<ArrayList<Integer>> gL,int Source,int v){

        List<Integer> bfs=new ArrayList<>();
        Queue<Integer> q=new LinkedList<>();

        boolean [] visited=new boolean[v+1];

        q.add(Source);
        visited[Source]=true;

        while(!q.isEmpty()){

            int node=q.poll();
            bfs.add(node);

            for(int nbr:gL.get(node)){
                if(!visited[nbr]){
                    visited[nbr]=true;
                    q.add(nbr);
                }
            }
        }
        return bfs;
    }

    ////////////////// Count Components (Corrected) /////////////////////////

    public static int componenets(ArrayList<ArrayList<Integer>> gL,  int v){
        int comp=0;

        boolean [] Visited=new boolean [v+1];
        Queue<Integer> q=new LinkedList<>();

        for(int i=1; i<=v; i++){

            if (!Visited[i]) {

                comp++;
                q.add(i);
                Visited[i]=true;

                while(!q.isEmpty()){
                    int node=q.poll();

                    for(int nbr : gL.get(node)){

                        if(!Visited[nbr]){
                            Visited[nbr]=true;
                            q.add(nbr);
                        }
                    }
                }
            }
        }

        return comp;  
    }

    ////////////////// Primâ€™s (MST) /////////////////////////

    static int spaningTree(int v,ArrayList<ArrayList<ArrayList<Integer>>> gLL){

        boolean visited[]=new boolean[v];

        PriorityQueue<Pair> q=new PriorityQueue<>();

        q.add(new Pair(0,0)); // wt=0, v=0

        int ans=0;

        while(!q.isEmpty()){

            Pair cur=q.remove();
            int u=cur.v;

            if(visited[u]) continue;

            ans += cur.wt;
            visited[u]=true;

            ArrayList<ArrayList<Integer>> neighbour=gLL.get(u);

            for (ArrayList<Integer> list:neighbour){
                int vertex=list.get(0);
                int wt=list.get(1);

                if(!visited[vertex]){
                    q.add(new Pair(wt,vertex));
                }
            }
        }

        return ans;
    }

    ////////////////// Dijkstra /////////////////////////////

    static int[] dijkstra (ArrayList<ArrayList<ArrayList<Integer>>> gLD,int v,int source){

        int dist[]=new int [v];
        Arrays.fill(dist,Integer.MAX_VALUE);
        boolean visited[]=new boolean[v];

        PriorityQueue<Pair> q=new PriorityQueue<>();

        dist[source]=0;

        q.add(new Pair(0,source));

        while(!q.isEmpty()){
            Pair cur=q.remove();
            int u=cur.v;

            if(visited[u]) continue;
            visited[u]=true;

            ArrayList<ArrayList<Integer>> neighbours = gLD.get(u);

            for(ArrayList<Integer> list : neighbours){

                int vertex=list.get(0);
                int wt=list.get(1);

                if(!visited[vertex] && dist[u] + wt < dist[vertex]){
                    dist[vertex] = dist[u] + wt;
                    q.add(new Pair(dist[vertex],vertex));
                }
            }
        }
        return dist;
    }

    ////////////////// Disjoint Set //////////////////////////

    public Graph(int n){
        rank=new int[n];
        parent=new int[n];
        this.n=n;
        for(int i=0; i<n; i++){
            parent[i]=i;
        }
    }

    int find(int x){
        if(parent[x]!=x)
            parent[x] = find(parent[x]); // path compression fix
        return parent[x];
    }

    void union(int x, int y){
        int xRoot=find(x),yRoot=find(y);

        if(xRoot==yRoot) return;

        if(rank[xRoot] < rank[yRoot])
            parent[xRoot]=yRoot;

        else if(rank[yRoot] < rank[xRoot])
            parent[yRoot]=xRoot;

        else{
            parent[yRoot]=xRoot;
            rank[xRoot]++;
        }
    }
/////////////////////////////Kahn's Algorithm(Topological sorting)//////////////////

static List<Integer> topologicalSort(ArrayList<ArrayList<Integer>> gL,int v){
int [] inDegree=new int[v+1];
ArrayList<Integer> ans=new ArrayList<>();

 for(int i=1; i<=v; i++){
        for(int e : gL.get(i)){
            inDegree[e]++;
        }
    }

//boolean [] vis=new boolean[v+1];

bfs(gL,v,ans,inDegree);

return ans;}

static void  bfs(ArrayList<ArrayList<Integer>> gL, int v, ArrayList<Integer> ans, int inDegree[]){

Queue <Integer> q=new LinkedList<>();
for(int i=1; i<=v; i++){
if(inDegree[i]==0){
q.add(i);
}}

while(!q.isEmpty()){
int cur=q.poll();
ans.add(cur);

for(int neighbour:gL.get(cur)){
if(--inDegree[neighbour]==0){
q.add(neighbour);}
}}}



}




class Pair implements Comparable<Pair>{
    int wt;
    int v;

    Pair(int wt,int v){
        this.wt=wt;
        this.v=v;
    }

    public int compareTo(Pair that){
        return this.wt - that.wt;
    }
}
